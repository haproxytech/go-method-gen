// Copyright 2025 HAProxy Technologies LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package eqdiff

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/haproxytech/go-method-gen/internal/common"
	"github.com/haproxytech/go-method-gen/internal/data"
	"github.com/haproxytech/go-method-gen/internal/generators/diff"
	"github.com/haproxytech/go-method-gen/internal/generators/equal"
	"github.com/haproxytech/go-method-gen/internal/parser"
	"github.com/haproxytech/go-method-gen/internal/writer"
	imp "golang.org/x/tools/imports"
	yaml "gopkg.in/yaml.v3"
)

// Options for the code generation
type Options struct {
	OutputDir     string // Output directory for generated files
	OverridesFile string // YAML file containing function overrides
	HeaderPath    string // Optional header file to prepend to generated files
}

// Generate generates Equal and Diff functions for the provided types.
func Generate(types []reflect.Type, opts Options) error {
	roots := []*data.TypeNode{}
	dir := opts.OutputDir
	var overrides map[string]common.OverrideFuncs
	var headerContent string

	// Read optional header content
	if opts.HeaderPath != "" {
		data, err := os.ReadFile(opts.HeaderPath)
		if err != nil {
			return err
		}
		for _, line := range strings.Split(string(data), "\n") {
			line = strings.TrimSpace(line)
			headerContent += fmt.Sprintf("// %s\n", line)
		}
	}
	// Read optional overrides file in YAML format
	if opts.OverridesFile != "" {
		data, err := os.ReadFile(opts.OverridesFile)
		if err != nil {
			return fmt.Errorf("failed to read overrides file: %w", err)
		}
		err = yaml.Unmarshal(data, &overrides)
		if err != nil {
			return fmt.Errorf("failed to parse overrides YAML: %w", err)
		}
	}
	// Parse all types into TypeNode trees using reflection
	for _, typ := range types {
		root := &data.TypeNode{}
		roots = append(roots, root)
		parser.Parse(root, typ, typ.PkgPath(), map[string]struct{}{})
	}

	// Track functions already generated by package/baseDir to avoid duplicates
	funcsByPkg := map[string]map[string]struct{}{}              // baseDir -> funcName
	setEqualsFuncsByBaseDir := map[string]map[string]struct{}{} // baseDir -> Equal funcs
	setDiffsFuncsByBaseDir := map[string]map[string]struct{}{}  // baseDir -> Diff funcs
	for _, root := range roots {
		// Generate Equal functions if not already present
		ctx := &data.Ctx{LeftSideComparison: "rec", RightSideComparison: "obj"}
		if !root.HasEqual {
			equal.Generate(root, ctx, equal.EqualCtx{
				Overrides: overrides,
			})
		}
		if len(ctx.SubCtxs) == 1 {
			contents := map[string]map[string]string{} // file -> func -> implementation
			writer.WriteEqualFiles(dir, "", contents, *ctx.SubCtxs[0])
			// Deduplicate functions per baseDir
			for file, funcs := range contents {
				for funName := range funcs {
					if funName == "Equal" || !strings.HasPrefix(funName, "Equal") {
						continue
					}
					basedirContent := filepath.Dir(file)
					equalsfuncs := setEqualsFuncsByBaseDir[basedirContent]
					if equalsfuncs == nil {
						equalsfuncs = map[string]struct{}{}
						setEqualsFuncsByBaseDir[basedirContent] = equalsfuncs

					}
					if _, exists := equalsfuncs[funName]; exists {
						delete(funcs, funName)
					}
					equalsfuncs[funName] = struct{}{}
				}
			}
			// Write files
			for file, funcs := range contents {
				baseDir := filepath.Dir(file)
				pkgfuncs, pkgExists := funcsByPkg[baseDir]
				if !pkgExists {
					pkgfuncs = map[string]struct{}{}
					funcsByPkg[baseDir] = pkgfuncs
				}

				var sb bytes.Buffer
				err := os.MkdirAll(baseDir, 0o755)
				if err != nil {
					return err
				}
				// Header, package, imports
				sb.WriteString(headerContent + "\n")
				pkg := funcs["Package"]
				sb.WriteString(pkg + "\n")
				delete(funcs, "Package")
				imports := funcs["Imports"]
				sb.WriteString(imports + "\n")
				delete(funcs, "Imports")
				// Append functions that were not already written
				var hasFunc bool
				for _, fun := range funcs {
					if _, funExists := pkgfuncs[fun]; funExists {
						continue
					}
					hasFunc = true
					pkgfuncs[fun] = struct{}{}
					sb.WriteString(fun + "\n")
				}
				// Format and write source
				if hasFunc {
					writeFormattedFile(sb.Bytes(), file)

				}
			}
		}

		// Generate Diff functions if not already present
		ctx = &data.Ctx{LeftSideComparison: "rec", RightSideComparison: "obj"}
		if !root.HasDiff {
			diff.Generate(root, ctx, diff.DiffCtx{
				Overrides: overrides,
			})
		}
		if len(ctx.SubCtxs) == 1 {
			contents := map[string]map[string]string{} // file -> func -> implementation
			writer.WriteDiffFiles(dir, "", contents, *ctx.SubCtxs[0])

			// Deduplicate Diff functions per baseDir
			for file, funcs := range contents {
				for funName := range funcs {
					if funName == "Diff" || !strings.HasPrefix(funName, "Diff") {
						continue
					}
					basedirContent := filepath.Dir(file)
					diffsfuncs := setDiffsFuncsByBaseDir[basedirContent]
					if diffsfuncs == nil {
						diffsfuncs = map[string]struct{}{}
						setDiffsFuncsByBaseDir[basedirContent] = diffsfuncs

					}
					if _, exists := diffsfuncs[funName]; exists {
						delete(funcs, funName)
					}
					diffsfuncs[funName] = struct{}{}
				}
			}

			// Write files
			for file, funcs := range contents {
				baseDir := filepath.Dir(file)
				pkgfuncs, pkgExists := funcsByPkg[baseDir]
				if !pkgExists {
					pkgfuncs = map[string]struct{}{}
					funcsByPkg[baseDir] = pkgfuncs
				}

				var sb bytes.Buffer
				err := os.MkdirAll(baseDir, 0o755)
				if err != nil {
					return err
				}
				sb.WriteString(headerContent + "\n")
				sb.WriteString("\n// Code generated by go-method-gen. DO NOT EDIT.\n\n")
				pkg := funcs["Package"]
				sb.WriteString(pkg + "\n")
				delete(funcs, "Package")
				imports := funcs["Imports"]
				sb.WriteString(imports + "\n")
				delete(funcs, "Imports")
				var hasFunc bool
				for _, fun := range funcs {
					if _, funExists := pkgfuncs[fun]; funExists {
						continue
					}
					hasFunc = true
					pkgfuncs[fun] = struct{}{}
					sb.WriteString(fun + "\n")
				}
				if hasFunc {
					writeFormattedFile(sb.Bytes(), file)
				}
			}
		}
	}
	return nil
}

// writeFormattedFile takes a byte slice of Go source code, formats it
// with go/imports, and writes the formatted code to the file at the
// given path. If an error occurs, it prints the error to stderr and
// returns the error.

func writeFormattedFile(contents []byte, file string) error {
	// Use x/tools/imports to format code and fix imports
	formattedCode, errFormat := imp.Process("", contents, nil)
	if errFormat != nil {
		fmt.Printf("file: %s, err: %s\n", file, errFormat.Error())
		fmt.Println(string(contents))
		return errFormat
	}
	return os.WriteFile(file, formattedCode, 0o644)
}
